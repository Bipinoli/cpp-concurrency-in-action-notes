#include <iostream>
#include <cassert>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>
#include <queue>
#include <random>
#include <functional>

using namespace std;


void swap(int a, int b, vector<int>& nums);


void quicksort_sequential(int start, int end, vector<int>& nums) {
  assert(start <= end);
  if (start == end) {
    return;
  }
  if (start + 1 == end) {
    if (nums[end] < nums[start]) {
      swap(start, end, nums);
    }
    return;
  }
  int pivot = nums[(start + end) / 2];

  // invariant:
  // left of l is strictly smaller than pivot
  // right or r is strictly greater than pivot
  int l = start;
  int r = end;

  int i = l;
  while (i <= r) {
    if (nums[i] < pivot) {
      swap(i, l, nums);
      l++; i++;
    } else if (nums[i] > pivot) {
      swap(i, r, nums);
      r--;
    } else {
      i++;
    }
  }
  quicksort_sequential(start, max(l-1, start), nums);
  quicksort_sequential(min(r+1, end), end, nums);
}


void swap(int a, int b, vector<int>& nums) {
  int temp = nums[a];
  nums[a] = nums[b];
  nums[b] = temp;
}


void test_quicksort(function<void(int,int,vector<int>&)> quicksort_func) {
  // Note:
  // Random device is internally a: /dev/urandom
  // Unlike /dev/random which waits for sufficient entropy
  // /dev/urandom doesn't wait and return immediately.
  // The device is locked and serially served on multiple calls.
  // The random events such as network, mouse interrupts, etc. are used to fill in the entropy pool
  //
  // Example:
  // head -c 8 /dev/urandom 
  // read the first 8 bytes from the file i.e random device
  random_device rand_dev;
  // we can use this true random source as a seed into pseduo random number generator engines.
  // The sequence of bytes generated by such engine can then be used as a random number.
  // With such engines we have more control over the distribution.
  // Also we won't need open() & read() system calls to read from the kernel random source
  auto random_seed = rand_dev();
  default_random_engine rand_eng(random_seed);
  uniform_int_distribution<int> rand_distrb(1, 100);
  
  for (int i=0; i<10000; i++) {
    int size = rand_distrb(rand_eng);
    cout << "Testing with size: " << size << endl;
    vector<int> nums;
    while (size--) {
      nums.push_back(rand_distrb(rand_eng));
    }
    vector<int> nums_cpy1(nums);
    vector<int> nums_cpy2(nums);
    sort(nums_cpy1.begin(), nums_cpy1.end());
    quicksort_func(0, nums_cpy2.size()-1, nums_cpy2);
    bool failed = false;
    for (int i=0; i<size; i++) {
      if (nums_cpy1[i] != nums_cpy2[i]) {
        failed = true;
        break;
      }
    }
    if (failed) {
      cout << "Test failed for: " << endl;
      for (auto it: nums) {
        cout << it << " ";
      }
      cout << endl;
      return;
    }
  } 

  cout << "Test passed!" << endl;
}


struct Task {
  int start_index;
  int end_index;
  vector<int>& nums;
  bool die;
};


void work(queue<Task>& task_q, mutex& q_mtx) {
  
}



int main() {
  // vector<int> nums {1, 15, 4, 13, 2, 18, 3, 12, 20, 6, 14, 17, 8, 9, 10, 5, 7, 11, 19, 16};
  //
  // queue<Task> task_q;
  // vector<thread> workers;
  //
  // for (unsigned int i=0; i < thread::hardware_concurrency() - 1; i++) {
  //   workers.push_back(thread([&](){
  //
  //   }));
  // }
  //
  // for (thread& w: workers) {
  //   w.join();
  // }
  //

  return 0;
}
