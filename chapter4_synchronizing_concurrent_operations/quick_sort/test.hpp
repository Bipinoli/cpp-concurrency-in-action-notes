#pragma once

#include <iostream>
#include <vector>
#include <functional>

namespace  test {

using namespace std;

void test_quicksort(function<void(int,int,vector<int>&)> quicksort_func) {
  // Note:
  // Random device is internally a: /dev/urandom
  // Unlike /dev/random which waits for sufficient entropy
  // /dev/urandom doesn't wait and return immediately.
  // The device is locked and serially served on multiple calls.
  // The random events such as network, mouse interrupts, etc. are used to fill in the entropy pool
  //
  // Example:
  // head -c 8 /dev/urandom 
  // read the first 8 bytes from the file i.e random device
  random_device rand_dev;
  // we can use this true random source as a seed into pseduo random number generator engines.
  // The sequence of bytes generated by such engine can then be used as a random number.
  // With such engines we have more control over the distribution.
  // Also we won't need open() & read() system calls to read from the kernel random source
  auto random_seed = rand_dev();
  default_random_engine rand_eng(random_seed);
  uniform_int_distribution<int> rand_distrb(1, 100);
  
  for (int i=0; i<10000; i++) {
    int size = rand_distrb(rand_eng);
    cout << "Testing with size: " << size << endl;
    vector<int> nums;
    while (size--) {
      nums.push_back(rand_distrb(rand_eng));
    }
    vector<int> nums_cpy1(nums);
    vector<int> nums_cpy2(nums);
    sort(nums_cpy1.begin(), nums_cpy1.end());
    quicksort_func(0, nums_cpy2.size()-1, nums_cpy2);
    bool failed = false;
    for (int i=0; i<size; i++) {
      if (nums_cpy1[i] != nums_cpy2[i]) {
        failed = true;
        break;
      }
    }
    if (failed) {
      cout << "Test failed for: " << endl;
      for (auto it: nums) {
        cout << it << " ";
      }
      cout << endl;
      return;
    }
  } 

  cout << "Test passed!" << endl;
}
  
}




