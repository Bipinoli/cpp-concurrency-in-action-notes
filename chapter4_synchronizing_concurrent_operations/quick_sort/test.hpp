#pragma once

#include <iostream>
#include <vector>
#include <functional>
#include <random>
#include "sequential.hpp"

namespace  test {

using namespace std;

class RandomGenerator {
public:
  RandomGenerator() {
    auto random_seed = rand_dev();
    rand_eng = default_random_engine(random_seed);
  }
  int generate_random_number(int min_val, int max_val) {
    uniform_int_distribution<int> rand_distrb(min_val, max_val);
    return rand_distrb(rand_eng);
  }
  vector<int> generate_random_vector(int size, int min_val, int max_val) {
    vector<int> nums;
    while (size--) {
      nums.push_back(generate_random_number(min_val, max_val));
    }
    return nums;
  }
private:
  // Note:
  // Random device is internally a: /dev/urandom
  // Unlike /dev/random which waits for sufficient entropy
  // /dev/urandom doesn't wait and return immediately.
  // The device is locked and serially served on multiple calls.
  // The random events such as network, mouse interrupts, etc. are used to fill in the entropy pool
  //
  // Example:
  // head -c 8 /dev/urandom 
  // read the first 8 bytes from the file i.e random device
  random_device rand_dev;
  // we can use this true random source as a seed into pseduo random number generator engines.
  // The sequence of bytes generated by such engine can then be used as a random number.
  // With such engines we have more control over the distribution.
  // Also we won't need open() & read() system calls to read from the kernel random source
  default_random_engine rand_eng;
};


bool verify(const vector<int>& nums) {
  for (int i=0; i<nums.size() -1; i++) {
    if (nums[i] > nums[i+1]) {
      return false;
    }
  }
  return true;
}

void test_sequential() {
  RandomGenerator rand_gen;
  for (int i=0; i<1000; i++) {
    auto sz = rand_gen.generate_random_number(1, 100);
    auto nums = rand_gen.generate_random_vector(sz, 1, 1000);
    sequential::quicksort_sequential(0, nums.size() - 1, nums);
    if (!verify(nums)) {
      cout << "Sequential quicksort test failed!" << endl;
      return;
    }
  }
  cout << "Sequential quicksort test passed!" << endl;
}

void test_concurrent() {
  concurrent::QuicksortWorkers workers;
  RandomGenerator rand_gen;
  vector<vector<int>> nums_batch;
  for (int i=0; i<1000; i++) {
    auto sz = rand_gen.generate_random_number(1, 100);
    auto nums = rand_gen.generate_random_vector(sz, 1, 1000);
    nums_batch.push_back(nums);
  }
  workers.sort_batch(nums_batch);
  for (auto& nums: nums_batch) {
    if (!verify(nums)) {
      cout << "Concurrent quicksort test failed!" << endl;
      return;
    }
  }
  workers.kill_workers();
  cout << "Concurrent quicksort test passed!" << endl;
}

} // namespace test